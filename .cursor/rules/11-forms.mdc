---
title: Form Handling with React Hook Form
type: auto_attached
file_patterns: ["**/components/**/*Form*.tsx", "**/validations/**/*.ts"]
description: Form patterns using React Hook Form and Zod
---

# Form Handling with React Hook Form

## Basic Form Setup

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// ✅ Good: Define schema first
const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

type LoginFormData = z.infer<typeof loginSchema>;

export function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });
  
  const onSubmit = async (data: LoginFormData) => {
    try {
      await signIn(data);
      toast.success('Signed in successfully');
    } catch (error) {
      toast.error('Failed to sign in');
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          {...register('email')}
          aria-invalid={!!errors.email}
        />
        {errors.email && (
          <span className="text-red-600">{errors.email.message}</span>
        )}
      </div>
      
      <div>
        <label htmlFor="password">Password</label>
        <input
          id="password"
          type="password"
          {...register('password')}
          aria-invalid={!!errors.password}
        />
        {errors.password && (
          <span className="text-red-600">{errors.password.message}</span>
        )}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Signing in...' : 'Sign In'}
      </button>
    </form>
  );
}
```

## Form Component Pattern (shadcn)

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';

// ✅ Good: Use shadcn Form components
export function ProfileForm({ user }: { user: User }) {
  const form = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      name: user.name,
      email: user.email,
      bio: user.bio || '',
    },
  });
  
  const onSubmit = async (data: ProfileFormData) => {
    await updateProfile(data);
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormDescription>
                Your public display name
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input type="email" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="bio"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Bio</FormLabel>
              <FormControl>
                <Textarea {...field} />
              </FormControl>
              <FormDescription>
                Tell us about yourself
              </FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <Button type="submit" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? 'Saving...' : 'Save Changes'}
        </Button>
      </form>
    </Form>
  );
}
```

## Complex Validation

```typescript
// ✅ Good: Custom validation rules
const passwordSchema = z
  .string()
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
  .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
  .regex(/[0-9]/, 'Password must contain at least one number')
  .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character');

const signUpSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: passwordSchema,
  confirmPassword: z.string(),
  age: z.number().int().min(18, 'You must be at least 18 years old'),
  terms: z.boolean().refine(val => val === true, {
    message: 'You must accept the terms and conditions',
  }),
}).refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'],
});

// ✅ Good: Async validation
const uniqueEmailSchema = z.string().email().refine(
  async (email) => {
    const exists = await checkEmailExists(email);
    return !exists;
  },
  { message: 'Email is already taken' }
);
```

## Dynamic Fields

```typescript
// ✅ Good: Array fields
import { useFieldArray } from 'react-hook-form';

const projectSchema = z.object({
  name: z.string().min(1),
  members: z.array(z.object({
    name: z.string().min(1),
    email: z.string().email(),
    role: z.enum(['admin', 'member', 'viewer']),
  })),
});

export function ProjectForm() {
  const form = useForm<ProjectFormData>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      name: '',
      members: [{ name: '', email: '', role: 'member' }],
    },
  });
  
  const { fields, append, remove } = useFieldArray({
    control: form.control,
    name: 'members',
  });
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <FormField
        control={form.control}
        name="name"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Project Name</FormLabel>
            <FormControl>
              <Input {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
      
      <div>
        <h3>Members</h3>
        {fields.map((field, index) => (
          <div key={field.id} className="space-y-2">
            <FormField
              control={form.control}
              name={`members.${index}.name`}
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Name</FormLabel>
                  <FormControl>
                    <Input {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name={`members.${index}.email`}
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input type="email" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <Button
              type="button"
              variant="destructive"
              onClick={() => remove(index)}
            >
              Remove
            </Button>
          </div>
        ))}
        
        <Button
          type="button"
          onClick={() => append({ name: '', email: '', role: 'member' })}
        >
          Add Member
        </Button>
      </div>
      
      <Button type="submit">Create Project</Button>
    </form>
  );
}
```

## Watch and Control

```typescript
// ✅ Good: Watch field changes
export function ConditionalForm() {
  const form = useForm<FormData>();
  
  const accountType = form.watch('accountType');
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <FormField
        control={form.control}
        name="accountType"
        render={({ field }) => (
          <FormItem>
            <FormLabel>Account Type</FormLabel>
            <Select onValueChange={field.onChange} defaultValue={field.value}>
              <SelectTrigger>
                <SelectValue placeholder="Select account type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="personal">Personal</SelectItem>
                <SelectItem value="business">Business</SelectItem>
              </SelectContent>
            </Select>
            <FormMessage />
          </FormItem>
        )}
      />
      
      {accountType === 'business' && (
        <FormField
          control={form.control}
          name="companyName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Company Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      )}
    </form>
  );
}

// ✅ Good: Manual control
export function CustomForm() {
  const form = useForm<FormData>();
  
  const handleReset = () => {
    form.reset({
      email: '',
      password: '',
    });
  };
  
  const handleSetValue = () => {
    form.setValue('email', 'user@example.com', {
      shouldValidate: true,
      shouldDirty: true,
    });
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields */}
      
      <div className="flex gap-2">
        <Button type="submit">Submit</Button>
        <Button type="button" onClick={handleReset}>Reset</Button>
        <Button type="button" onClick={handleSetValue}>Set Email</Button>
      </div>
    </form>
  );
}
```

## File Uploads

```typescript
// ✅ Good: File upload handling
const fileSchema = z.object({
  avatar: z
    .instanceof(FileList)
    .refine(files => files.length > 0, 'Avatar is required')
    .refine(files => files[0]?.size <= 5 * 1024 * 1024, 'Max file size is 5MB')
    .refine(
      files => ['image/jpeg', 'image/png', 'image/webp'].includes(files[0]?.type),
      'Only JPEG, PNG, and WebP files are allowed'
    ),
});

export function AvatarUploadForm() {
  const form = useForm<FileFormData>({
    resolver: zodResolver(fileSchema),
  });
  
  const onSubmit = async (data: FileFormData) => {
    const file = data.avatar[0];
    const formData = new FormData();
    formData.append('avatar', file);
    
    await uploadAvatar(formData);
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <FormField
        control={form.control}
        name="avatar"
        render={({ field: { onChange, value, ...field } }) => (
          <FormItem>
            <FormLabel>Avatar</FormLabel>
            <FormControl>
              <input
                type="file"
                accept="image/jpeg,image/png,image/webp"
                onChange={(e) => onChange(e.target.files)}
                {...field}
              />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
      
      <Button type="submit">Upload</Button>
    </form>
  );
}
```

## Server Actions Integration

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useTransition } from 'react';

// ✅ Good: Use with Server Actions
export function CreatePostForm() {
  const [isPending, startTransition] = useTransition();
  
  const form = useForm<PostFormData>({
    resolver: zodResolver(postSchema),
  });
  
  const onSubmit = (data: PostFormData) => {
    startTransition(async () => {
      const result = await createPost(data);
      
      if (result.success) {
        form.reset();
        toast.success('Post created successfully');
      } else {
        form.setError('root', {
          message: result.error,
        });
      }
    });
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields */}
      
      {form.formState.errors.root && (
        <div className="text-red-600">
          {form.formState.errors.root.message}
        </div>
      )}
      
      <Button type="submit" disabled={isPending}>
        {isPending ? 'Creating...' : 'Create Post'}
      </Button>
    </form>
  );
}
```

## Form State Management

```typescript
// ✅ Good: Check form state
export function ComplexForm() {
  const form = useForm<FormData>();
  
  const {
    isDirty,
    isValid,
    isSubmitting,
    isSubmitted,
    isSubmitSuccessful,
    errors,
    touchedFields,
    dirtyFields,
  } = form.formState;
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields */}
      
      <div className="flex gap-2">
        <Button
          type="submit"
          disabled={!isDirty || !isValid || isSubmitting}
        >
          {isSubmitting ? 'Saving...' : 'Save Changes'}
        </Button>
        
        {isDirty && (
          <Button type="button" onClick={() => form.reset()}>
            Cancel
          </Button>
        )}
      </div>
      
      {isSubmitSuccessful && (
        <div className="text-green-600">
          Form submitted successfully!
        </div>
      )}
    </form>
  );
}
```

## Reusable Form Components

```typescript
// ✅ Good: Create reusable form components
interface TextFieldProps {
  name: string;
  label: string;
  type?: 'text' | 'email' | 'password';
  description?: string;
  placeholder?: string;
}

export function TextField({
  name,
  label,
  type = 'text',
  description,
  placeholder,
}: TextFieldProps) {
  const form = useFormContext();
  
  return (
    <FormField
      control={form.control}
      name={name}
      render={({ field }) => (
        <FormItem>
          <FormLabel>{label}</FormLabel>
          <FormControl>
            <Input type={type} placeholder={placeholder} {...field} />
          </FormControl>
          {description && <FormDescription>{description}</FormDescription>}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}

// Usage
export function MyForm() {
  const form = useForm<FormData>({
    resolver: zodResolver(schema),
  });
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <TextField
          name="email"
          label="Email"
          type="email"
          description="We'll never share your email"
        />
        <TextField
          name="password"
          label="Password"
          type="password"
        />
        <Button type="submit">Submit</Button>
      </form>
    </Form>
  );
}
```

## Best Practices

1. **Always use Zod validation** - Type-safe and runtime-safe
2. **Use shadcn Form components** - Accessible and consistent
3. **Handle loading states** - Show feedback during submission
4. **Disable submit when invalid** - Prevent invalid submissions
5. **Reset form after success** - Clear form on successful submission
6. **Show error messages** - Clear, specific error messages
7. **Validate on blur** - Better UX than on change
8. **Use default values** - Always provide default values
9. **Handle async validation** - Check uniqueness, availability
10. **Test your forms** - Write tests for validation logic

## Form Validation Checklist

- [ ] Schema defined with Zod
- [ ] All fields have labels
- [ ] Error messages are clear
- [ ] Loading state during submission
- [ ] Submit button disabled when invalid
- [ ] Form resets after success
- [ ] Accessibility attributes (aria-invalid, aria-describedby)
- [ ] Keyboard navigation works
- [ ] File uploads validated
- [ ] Async validation handled
